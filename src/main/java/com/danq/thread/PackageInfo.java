package com.danq.thread;

public class PackageInfo {

    /**
     *
     * 乐观锁：不进行加锁，而是尝试通过校验的方式来进行修改数据
     * 悲观锁：上锁，保证同一时间只有一个线程在修改数据
     *
     * 自旋锁：在抢占锁失败后不会进行阻塞，而是进行循环持续尝试获取锁，这样的方式好处在于避免CPU频繁切换线程状态
     * 适应性自旋锁：
     * 可以理解为优化版自旋锁，自旋锁如果长时间循环尝试获取锁的话会造成CPU长时间空转，如果线程较少，锁占用
     * 时间较短还好，如果抢占线程多，而且占用时间长的话影响很大，所以适应性自旋锁就是做一个限制，只循环固定的次数，超过
     * 就阻塞线程，不自旋了
     *
     * 无锁、偏向锁、轻量级锁、重量级锁：
     *
     * 这是Java synchronized 的升级过程
     *
     * 偏向锁：HotSpot 作者发现，常常是一个线程多次获得通一把锁，所以为了避免这种一个人竞争的情况，引入了偏向锁
     * 如果是同一个线程之间获得锁，无需争抢。
     *
     * 轻量级锁：当抢占锁的线程不多，并且持有锁的时间不长时，就不会进行阻塞线程，而是使用自旋的方式让线程等待
     * 这样可以避免线程阻塞导致的CPU状态转换，而自旋会一直循环尝试获得锁。
     *
     * 重量级锁：当抢占锁的线程较多，并且持有锁的时间较长时，自旋的线程多而且次数也多，为了避免这种长时间的CPU空转
     * 就将所有未获得锁的线程阻塞。
     *
     * 公平锁：指多个线程按照申请锁的顺序来获取锁
     * 非公平锁：多个线程加锁时直接尝试获取锁，抢就完了
     *
     * 可重入锁：又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁
     * （前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。
     * 非可重入锁：同一个线程，无法多次获得同一把锁，就有可能出现自己和自己抢锁的情况
     *
     * 独享锁：排他锁，是指该锁一次只能被一个线程所持有
     * 共享锁：该锁可被多个线程所持有
     *
     */

}
